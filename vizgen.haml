%html{lang:'en'}
  %head
    %meta{name:"viewport",content:"width=device-width, initial-scale=1.0"}
    %link{href:'bootstrap/css/bootstrap.css', rel:'stylesheet'}
    %link{href:'style.css', rel:'stylesheet'}

  %body
    .navbar.navbar-inverse.navbar-static-top{role:'navigation'}
      .container
        .navbar-header
          %button.navbar-toggle{type:'button',data-toggle:'collapse',data-target:'.navbar-collapse'}
            %span.sr-only Toggle navigation
            %span.icon-bar
            %span.icon-bar
            %span.icon-bar
          %a.navbar-brand{href:'index.html'} peptagram
        .navbar-collapse.collapse
          %ul.nav.navbar-nav
            %li
              %a{href:'index.html'} home
            %li
              %a{href:'vizhelp.html'} visualisation help
            %li.active
              %a{href:'vizgen.html'} visualisation generation
            %li
              %a{href:'api.html'} programming api
    #banner
      .container
        .row
          .col-lg-12
            %h1 PEPTAGRAM
            %h4 hassle-free visualisation of proteomics data

    #tintedtext
      .container
        .row
          .col-lg-7.col-md-7.col-sm-8
            :markdown

              # Generating Visualisations

              `peptagram` consists of a set of Python scripts that converts proteomics data into an HTML5 visualisation. 

              To generate the visualisations, you must have [python](http://python.org) installed. If you have the python installer [pip](http://www.pip-installer.org/en/latest/installing.html), then:

                  > pip install peptagram

              Otherwise, download and unzip the package from <https://github.com/boscoh/peptagram/archive/master.zip>

              And install from the package directory:

                  > python setup.py install

              `peptagram` has two python dependencies: 

                1. [pymzML](https://github.com/pymzml/pymzML) to read `.mzML` files
                2. [uniprot](https://github.com/boscoh/uniprot) to get protein sequences from <http://uniprot.org>. 

              These should be installed automatically from the above scripts, but if that fails, you may need to install them manually.

    #plaintext
      .container
        .row
          .col-lg-7.col-md-7.col-sm-8
            :markdown

              # Worked Examples

              `peptagram` consists of Python modules that convert proteomics data into an HTML5 visualisation. 

              A set of examples can be found in this ~100 MB download:

              &nbsp;&nbsp;
              <a class='btn btn-primary' type='button' href='http://monash.edu/proteomics/peptagram/examples-0.1a.zip'>
                Download Examples (~135MB)
              </a> 

              For a fully realized visualisation, `peptagram` requires:

              1. peptide-spectrum matches
              2. protein groupings
              3. sequences of identified proteins
              4. tandem MS/MS spectra 

              Given the variety of proteomics formats, different combinations of data are needed to generate visualisation.

              In this download, we have examples of:

              - Morpheus & mzML
              - TPP & fasta/uniprot
              - TPP & x!Tandem
              - TPP & Mascot & fasta
              - MaxQuant & fasta

              These will be discussed in detail below.

    #tintedtext
      .container
        .row
          .col-lg-7.col-md-7.col-sm-8
            :markdown

              ### Example: Morpheus & mzML

              Morpheus is a search engine designed for high-quality data, where the assumption that MS/MS peaks are well-resolved results in better performance. As Morpheus does not come with a bundled viewer, `peptagram` provides a unique tool to view Morpheus proteomics search results. 

              In the unzipped examples directory, the morpheus script is `run_morpheus.py`. The script first imports the relevant `peptagram` modules:

                  import peptagram.morpheus
                  import peptagram.mzml
                  import peptagram.proteins

              The following function reads in the sequences and protein groupings from `.protein_group.tsv`, the peptide-spectrum matches from `.PSMs.tsv` and the modifications from `modifications.tsv`, and put into a python data-structure called `proteins`:

                  proteins = peptagram.morpheus.get_proteins(
                      'morpheus/OK20130822_MPProtomap_KO1.protein_groups.tsv',
                      'morpheus/OK20130822_MPProtomap_KO1.PSMs.tsv',
                      'morpheus/modifications.tsv'
                      )

              __OPTIONAL:__ If you did the Morpheus search with .mzML files, you can load in the raw spectra into `proteins` from the `.mzML` file, which will be displayed. The function will match the spectra in the `.mzML` to  entries in the `.PSM.tsv` file. For this case, only one data-set has been read into `proteins`, so the second parameter is given 0, to refer to the first data-set:

                  i_source = 0
                  peptagram.mzml.load_mzml(
                      proteins, i_source, 
                      'morpheus/OK20130822_MPProtomap_KO1.mzML')

              Now that `proteins` is properly read, we can generate the visualation. The visualisation requires a little bit information to provide useful annotations for the user.  This is to be put in a `data` dictionary:

                  data = {
                    'title': 'Morpheus Example', 
                    'proteins': proteins,
                    'source_labels': [''],
                    'color_names': ['', '', ''],
                    'mask_labels': [],
                  }

              A description of the fields:
                
                - `title`: the text that will be displayed at the top of the web-app
                - `proteins`: the proteins data structure referred to above
                - `source_labels`: in comparison mode, this is the label for the different proteomics experiment. ignored if it is an empty list
                - `color_names`: in comparison mode, the labels for the colors in the legend
                - `mask_labels`: alternative masking for the display of higher accuracies

              The `data` dictionary is then passed into the function that generates the visualisation web-app in the indicated directory:

                  peptagram.proteins.make_sequence_overview_visualisation(
                      data, 'morpheus/overview')

              Which is run on the command-line in the examples directory:

                  python run_morpheus.py

    #plaintext
      .container
        .row
          .col-lg-7.col-md-7.col-sm-8
            :markdown

              ### Example: TPP & fasta/uniprot

              The Transatlantic Protein Pipeline (TPP) represents one of the largest open-source proteomics toolkits. As the TPP have pushed for their `.protXML` and `.pepXML` formats as standards, the search results can come from any number of search-engines. As such, by handling TPP files, `peptagram` can  handle search data indirectly from many different sources.

              The example script is called `run_tpp.py`, and the requiredn modules are:

                  import peptagram.tpp
                  import peptagram.proteins

              First, the protein-groups and peptide-spectrum matches are read in from a `.protXML` file and potentially several `.pepXML` files, which is treated as a list of filenames:

                  protein_error = 0.01

                  proteins, source_names = peptagram.tpp.get_proteins_and_sources(
                      'tpp/hca-lysate-16.prot.xml', 
                      ['tpp/hca-lysate-16.pep.xml'],
                      peptide_error=0.05,
                      protein_error=protein_error)

              Two extra parameters are provided, `peptide_error` is a false-positive-error cutoff for the peptide entries in the `.pepXML` file, and `protein_error` is a false-positive-error cutoff for the `.protXML` file. These are calculated from the probability-error distributions included in every `.pepXML` and `.protXML` file.

              As TPP files lack sequences, we must read them in externally. From our experience, sequence identifiers for protein sequences are oftern formatted differently by different programs, even if it is in essence, the same identifier. As such, there are  hooks in `peptagram` to clean up sequence-identifier for matching purposes. This is basically a idempotent string transformation function, such as:

                  def clean_seqid(seqid):
                    if '|' in seqid:
                      return seqid.split('|')[1]
                    else:
                      return seqid

              Now we load the protein sequences from a `.fasta` file using `clean_seqid` to transform sequence identifiers and match the identifiers from `proteins` and the `.fasta` file:

                  peptagram.proteins.load_fasta_db_into_proteins(
                      proteins, 
                      'tpp/HUMAN.fasta', 
                      clean_seqid=clean_seqid,
                      iso_leu_isomerism=False)

              Notice the `iso_leu_isomerism` flag, which is required for some packages that don't distinguish this mass isomerism in peptides.

              **Alternatively**: you can load the sequences directly from <http://uniprot.org>. This can be seen in the `run_tpp_uniprot.py` script. The sequence loading occurs with the alternative function, which requires a `cache_basename` - a filename location for temporary files:

                  peptagram.proteins.load_sequences_from_uniprot(
                      proteins, 
                      clean_seqid=clean_seqid,
                      cache_basename='tpp/uniprot')
                      
              The sequences are loaded into the data structure, and the positions relative to the full protein of the peptides in the peptide-spectrum-matches are calculated.

              And finally, the step to generate the visualisations:

                  data = {
                    'title': 'TPP example',
                    'proteins': proteins,
                    'source_labels':source_names,
                    'color_names': ['P=1', 'P=0', ''],
                    'mask_labels': [protein_error],
                  }
                  peptagram.proteins.make_sequence_overview_visualisation(
                    data, 'tpp/overview')

    #tintedtext
      .container
        .row
          .col-lg-7.col-md-7.col-sm-8
            :markdown

              ### Example: X!Tandem & TPP

              The default search-engine that comes with the TPP is X!Tandem. The great thing about `.tandem` files is that they provide both protein sequences and the MS/MS spectra for each peptide-spectrum match. You can thus generate a full `peptagram` visualization with `.tandem`, `.protXML` and `.pepXML` files. 

              The example script is `run_xtandem.py`. First, read in the `proteins` data structure from the `.pepXML` and `.protXML` files:

                  import peptagram.parse
                  import peptagram.xtandem
                  import peptagram.tpp
                  import peptagram.proteins

                  errors = [0.05, 0.025, 0.01]
                  
                  proteins, source_names = peptagram.tpp.get_proteins_and_sources(
                      'xtandem/interact.prot.xml', 
                      ['xtandem/interact.pep.xml'], 
                      peptide_error=max(errors))

                Here, `.pepXML` was generated from 3 different `.tandem` files:

                    tandems = [
                      'xtandem/Seq23282_E1O1.tandem',
                      'xtandem/Seq23283_E1O1.tandem',
                      'xtandem/Seq23284_E1O1.tandem',
                    ]

               As such, we need to make use of the `source_names` return variable from above, which contains the names of the source files in the `.pepXML` entries. Hopefully, these will match the `.tandem` to the `source_names`. To figure out the match of the `.tandem` files to the `source_names`:

                  def get_i_source(tandem, source_names):
                    basename = os.path.splitext(os.path.basename(tandem))[0]
                    for i, source_name in enumerate(source_names):
                      if basename in source_name:
                        return i
                    raise IOError('Couldn\'t match {} to {}'.format(basename, source_names))

              Once matched, we load the `.tandem` files into `proteins`:

                  for tandem in tandems:
                    i_source = get_i_source(tandem, source_names)
                    peptagram.xtandem.load_xtandem_into_proteins(proteins, tandem, i_source)

              Then we can generate the web-app:

                  data = {
                    'title': 'X!Tandem example',
                    'proteins': proteins,
                    'source_labels': map(peptagram.parse.basename, source_names),
                    'color_names': ['P=1', 'P=0', ''],
                    'mask_labels': errors,
                  }
                  peptagram.proteins.make_graph_comparison_visualisation(
                      data, 'xtandem/comparison')


    #plaintext
      .container
        .row
          .col-lg-7.col-md-7.col-sm-8
            :markdown

              ### Example: TPP & Mascot & fasta

              Despite the weirdness of `.dat` files, Mascot is one of the oldest and most popular search engines. Here, we have a parser for Mascot `.dat` files, which is a mish-mash of mime-type, xml, and random acts of text. As Mascot does not group proteins, we only provide an example where mascot `.dat` files have been processed by the TPP. 

              In this instance, the `.pepXML` file was generated from 2 mascot `.dat` files:

                  mascot_dats = [
                    'mascot/F022043.dat',
                    'mascot/F022045.dat',
                  ]

               So first we read in the `proteins` data structure from the `.pepXML` and `.protXML` files:

                  import peptagram.parse
                  import peptagram.mascot
                  import peptagram.tpp
                  import peptagram.proteins

                  proteins, source_names = peptagram.tpp.get_proteins_and_sources(
                      'mascot/interact.prot.xml', 
                      ['mascot/interact.pep.xml'], 
                      peptide_error=None,
                      protein_error=None)

              We define a function to match the `.dat` files to the `source_names` in the original read with this function:

                  def get_i_source(fname, source_names):
                    basename = os.path.splitext(os.path.basename(fname))[0]
                    for i, source_name in enumerate(source_names):
                      if basename in source_name:
                        return i
                    raise IOError('Couldn\'t match {} to {}'.format(basename, source_names))

              Then we load the MS/MS spectra from the `.dat` files:

                  for mascot_dat in mascot_dats:
                    i_source = get_i_source(mascot_dat, source_names)
                    peptagram.mascot.load_mascot_dat_to_proteins(proteins, i_source, mascot_dat)

              At this point `proteins` contain protein groupings, peptide-spectrum matches and raw spectra. We still need the protein sequences. Then we load the sequences in from a `.fasta` database with a sequence-identifier normalizng fucntion `clean_seqid`:

                  def clean_seqid(seqid):
                    if '|' in seqid:
                      return seqid.split('|')[1]
                    else:
                      return seqid

                  peptagram.proteins.load_fasta_db_into_proteins(
                      proteins, 'mascot/HUMAN.fasta', clean_seqid)

              Finally, we generate the webapp:

                  data = {
                    'title': 'Mascot example',
                    'proteins': proteins,
                    'source_labels': map(peptagram.parse.basename, source_names),
                    'color_names': ['P=1', 'P=0', ''],
                    'mask_labels': [],
                  }
                  peptagram.proteins.make_graph_comparison_visualisation(
                      data, 'mascot/comparison')

    #tintedtext
      .container
        .row
          .col-lg-7.col-md-7.col-sm-8
            :markdown

              ### Example: MaxQuant & fasta

              We have used MaxQuant mainly for its ability to do isotype-labelling comparisons (eg SILAC). Maxquant results are stored as tab-separated-value files as `.txt` files in a summary directory. 

              The script is `run_maxquant` that reads the relevant `.txt` files from the summary directory:

                  import peptagram.maxquant
                  import peptagram.proteins

                  proteins, sources = peptagram.maxquant.get_proteins_and_sources(
                      'maxquant/summary')

              A word of warning: the spectra read in is only a list of matched peaks, which is not really that useful for evaluating the quality of the peak matching. Unfortunately, the MaxQuant output was quite confusing and it was not clear how to calculate the theoretical heavy and light isotope peaks.

              Then, we use the next function to use the isotype intensity ratios to populate the `intensity` field in the peptide-spectrum matches, which is used to generate the color:

                  peptagram.maxquant.calculate_ratio_intensities(proteins, max_ratio=1.5)

              As MaxQuant files do not contain sequences, here's the `.fasta` loading:

                  def clean_seqid(seqid):
                    if '|' in seqid:
                      return seqid.split('|')[1]
                    else:
                      return seqid

                  peptagram.proteins.load_fasta_db_into_proteins(
                      proteins, 
                      'maxquant/yeast_orf_trans_all_05-Jan-2010.fasta', 
                      clean_seqid=clean_seqid)

              And now we can generate the webapp, where the colors represents the SILAC ratios. As such we give the ratios as the `color_names`:

                  data = {  
                    'title': 'Maxquant example', 
                    'proteins': proteins,
                    'source_labels': sources,
                    'color_names': ['1.5', '1', '0.66'],
                    'mask_labels': [],
                  }
                  peptagram.proteins.make_graph_comparison_visualisation(
                    data, 'maxquant/comparison')

    #footer
      .container
        .row
          .col-lg-7.col-md-7.col-sm-8
            :markdown
                Developed at the [Monash Proteomics Facility](http://monash.edu/proteomics).  <br>
                Source code hosted at <http://github.com/boscoh/peptagram>.   <br>
                Copyright &copy; 2013, Bosco K. Ho.

    %script{src:'jquery-1.10.2.min.js'}
    %script{src:'bootstrap/js/bootstrap.js'}
